<html>
  <head>
    <style>
      body {margin: 0; padding: 5px; background-color: #ffffff}
      button {font: 12px sans-serif;}
      p {margin: 5px 0 5px 0}
      #hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #00000000; outline: 0.5px solid #222; height: 15px}
      #hl span {padding: 0 3px 0 3px}
      #status {overflow: hidden; white-space: nowrap}
      #match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
      * {box-sizing:border-box,margin:.25em 0}
      .col{display:table-cell}
      .col-1{width:5%}
      .col-2{width:15%}
      .col-3{width:22%}
      .col-4{width:30%}
      .col-5{width:40%}
      .col-6{width:50%}
      .row{display:table;border-spacing:0.2em 0;width:100%;display:flex}
      .w-100{width:100%;display:flex}
      .graphCol{flex: 80%; padding: 0.25em;}
      .configCol{flex: 20%; padding: 0.25em;}
      .configBlock{position:fixed; overflow-y:auto; top: 5px; bottom: 5px; width:19%;}
      .sidebarToggle{font: 10px; width:10; padding:0;}
      .margins {margin: 5px 1px}
      .vmargins {margin: 0px 1px;}
      .context {display: inline-block; position:fixed; top:0px; left:0px; min-width:200px;
                color:#fff;  background:#262933; font-size:9pt; border:1px solid #333333;
                border-radius:6px; box-shadow:2px 2px 2px -1px rgba(0, 0, 0, 0.5);
                padding:3px 0px; -webkit-touch-callout:none; -webkit-user-select:none;
                -khtml-user-select:none; -moz-user-select:none; -ms-user-select:none;
                user-select:none; z-index:200;}
      .context .item {padding:4px 19px; cursor:default; color:inherit;}
      .context .item:hover { background:#2777FF;}
      .context .item:hover .hotkey {color: #fff;}
      .context .disabled {color:#878B90;}
      .context .disabled:hover {background:inherit;}
      .context .disabled:hover .hotkey {color: #878B90;}
      .context .separator {margin:4px 0px; height:0; padding:0; border-top:1px solid #454545;}
      .hotkey {color:#878B90; float:right;}
    </style>
  </head>
  <body style='font: 12px Verdana, sans-serif'>
    <div class="c">
      <div class="row">
        <div class="graphCol">
          <div id='canvasDiv'><canvas id='canvas' style='width: 100%;'></canvas></div>
          <div id='box'><div id='hl'><span></span></div></div>
          <p id='match'>Matched: <span id='matchedLabel'></span></p>
          <p id='status'>&nbsp;</p>
        </div>
        <button class="sidebarToggle" onclick="toggleSidebarVisibility()">&lt;</button>
        <div class="configCol">
          <div class="configBlock">
            <div id="titleDiv">
              <b><center><span id="graphTitleSpan">Flamegraph</span></center></b>
              <hr>
            </div>
            <div class="row">
              <label for="highlightInput">Highlight:</label>
              <input placeholder="String or /regex/" name="highlightInput" id="highlightInput"/>
            </div>
            <div class="row">
              <button onclick="highlightApply()">Highlight</button>
              <button onclick="highlightClear()">Clear</button>
            </div>
            <br>
            <hr>
            <br>

            <label>Minimal frame width (in pixels):</label><br>
            <input id="minFrameWidthInPx" value="0.25"/><br>
            <div>
              <label><input type="checkbox" id="isReversedInput">Reversed</label>
              <span id="isNormalizedDiv" style="display:none;">
                <label><input type="checkbox" id="isNormalized" name="isNormalized">Normalized</label>
              </span>
            </div>
            <div>
              <label><input type="radio" id="sortByNameRadio" name="sortBy" value="name">Sort by name</label>
              <label><input type="radio" id="sortByWidthRadio" name="sortBy" value="width" checked>Sort by width</label>
            </div>
            <br>

            <div class="row">
              <div class="col">
                <label for="newTransformType">Add a transform:</label>

                <select name="newTransformType" id="newTransformType">
                  <option value="filter">Filter</option>
                  <option value="remove">Remove</option>
                  <option value="replace">Replace</option>
                </select>
              </div>
              <div class="col col-2">
                <button onclick="addNewTransform()">Add</button>
              </div>
            </div>
            <p><i>Right-click any stackframe to add common transforms.</i></p>
            <br>

            <div id="transformsContainer">
            </div>

            <div id="transformReplaceTemplate" style="display:none">
              <div class="row">
                <div class="col col-3">
                  <label>Replace:</label><br>
                </div>
                <div class="col">
                  <input type="checkbox" class="chkEnabled" onclick="refreshAfterEnabledToggle()" checked>
                  <button class="minibtn btnMoveUp" title="Move up" onclick="moveTransformUp(this)">↑</button>
                  <button class="minibtn btnMoveDown" title="Move down" onclick="moveTransformDown(this)">↓</button>
                  <button class="minibtn btnClone" title="Clone" onclick="cloneTransform(this)">☍</button>
                  <button class="minibtn btnDelete" title="Delete" onclick="deleteTransform(this)">✖</button>
                </div>
              </div>
              <div class="row" style="margin-top:1px;margin-bottom:1px">
                <div class="col w-100 no-vmargins">
                  <input class="what no-vmargins w-100" placeholder="String or /regex/"/><br>
                </div>
              </div>
              <div class="row" style="margin-top:1px;margin-bottom:1px">
                <div class="col w-100 no-vmargins">
                  <input class="replacement no-vmargins w-100" placeholder="Replacement"/><br>
                </div>
              </div>
            </div>

            <div id="transformFilterTemplate" style="display:none" class="margins">
              <div class="row">
                <div class="col col-3">
                  <label class="label">Filter:</label><br>
                </div>
                <div class="col">
                  <input type="checkbox" class="chkEnabled" onclick="refreshAfterEnabledToggle()" checked>
                  <button class="minibtn btnMoveUp" title="Move up" onclick="moveTransformUp(this)">↑</button>
                  <button class="minibtn btnMoveDown" title="Move down" onclick="moveTransformDown(this)">↓</button>
                  <button class="minibtn btnClone" title="Clone" onclick="cloneTransform(this)">☍</button>
                  <button class="minibtn btnDelete" title="Delete" onclick="deleteTransform(this)">✖</button>
                </div>
              </div>
              <div class="row">
                <div class="col w-100 margins">
                  <input class="what margins w-100" placeholder="String or /regex/"/><br>
                </div>
              </div>
            </div>

            <hr>
            <button onclick="applyConfiguration()">Apply</button>
          </div>
        </div>
      </div>
    </div>
    <script>
      // This file was derived from flamegraph.html from the project
// https://github.com/jvm-profiling-tools/async-profiler
// Licensed under the Apache License, Version 2.0. Copyright 2020 Andrei Pangin

/// Constants
const canvas = document.getElementById('canvas');
const c = canvas.getContext('2d');
const hl = document.getElementById('hl');
const status = document.getElementById('status');
const matchContainer = document.getElementById('match');
const transformFilterTemplate = document.getElementById('transformFilterTemplate');
const transformReplaceTemplate = document.getElementById('transformReplaceTemplate');
const sidebarToggleButton = document.getElementsByClassName('sidebarToggle')[0];
const sidebarWidth = document.getElementsByClassName('configCol')[0].offsetWidth
const qString = new URLSearchParams(window.location.search)

var sidebarVisible = true;
var canvasWidth;

if (qString.get('hide-sidebar') == 'true') {
  sidebarVisible = false;
}

function updateSidebarState() {
  let style = oneByClass(document, 'configCol').style
  if (sidebarVisible) {
    style.display = 'block';
    sidebarToggleButton.innerText = ">";
    canvasWidth = window.innerWidth - sidebarWidth - 36;
  } else {
    style.display = 'none';
    sidebarToggleButton.innerText = "<";
    canvasWidth = window.innerWidth - 36;
  }
}

updateSidebarState();

var graphTitle = "";
var isDiffgraph = true;
var normalizeDiff = false, b_scale_factor;
var reverseGraph = false;
var idToFrame = ["[unknown_Java]",
"foward_copy_longs",
"zero_longs",
"clojure.main.main",
"clojure.lang.Var.applyTo",
"clojure.lang.RestFn.applyTo",
"clojure.lang.AFn.applyToHelper",
"clojure.lang.RestFn.invoke",
"clojure.main/main",
"clojure.main/repl-opt",
"clojure.main/repl",
"clojure.main/repl/fn--",
"clojure.main/repl/read-eval-print--",
"clojure.main/repl/read-eval-print--/fn--",
"clojure.core/eval",
"clojure.lang.Compiler.eval",
"user$eval.invoke",
"user$eval.invokeStatic",
"InterpreterRuntime::_new(JavaThread*, ConstantPool*, int)",
"InstanceKlass::initialize(Thread*)",
"InstanceKlass::initialize_impl(instanceKlassHandle, Thread*)",
"InstanceKlass::link_class(Thread*)",
"InstanceKlass::link_class_impl(instanceKlassHandle, bool, Thread*)",
"Verifier::verify(instanceKlassHandle, Verifier::Mode, bool, Thread*)",
"ClassVerifier::verify_class(Thread*)",
"ClassVerifier::verify_method(methodHandle, Thread*)",
"ClassVerifier::verify_field_instructions(RawBytecodeStream*, StackMapFrame*, constantPoolHandle, Thread*)",
"SignatureStream::as_symbol(Thread*)",
"SymbolTable::lookup(Symbol const*, int, int, Thread*)",
"Symbol::equals(char const*, int) const",
"clj-async-profiler.core/start",
"clj-async-profiler.core/attach-agent",
"clojure.lang.Reflector.invokeInstanceMethod",
"clojure.lang.Reflector.invokeMatchingMethod",
"java.lang.reflect.Method",
"sun.reflect.DelegatingMethodAccessorImpl",
"sun.reflect.NativeMethodAccessorImpl",
"sun.reflect.NativeMethodAccessorImpl.invoke0",
"sun.tools.attach.HotSpotVirtualMachine.loadAgentPath",
"sun.tools.attach.HotSpotVirtualMachine.loadAgentLibrary",
"sun.tools.attach.BsdVirtualMachine.execute",
"sun.tools.attach.HotSpotVirtualMachine.readInt",
"java.lang.Integer.parseInt",
"clj-async-profiler.core/start/fn--",
"clojure.core/slurp",
"clojure.core/apply",
"clojure.java.io/reader",
"clojure.java.io/fn--/G----",
"clojure.java.io/fn--",
"java.io.FileInputStream.<init>",
"java.io.FileInputStream.open",
"java.io.FileInputStream.open0",
"java.io.FileNotFoundException.<init>",
"java.io.IOException.<init>",
"java.lang.Exception.<init>",
"java.lang.Throwable.<init>",
"java.lang.Throwable.fillInStackTrace",
"Java_java_lang_Throwable_fillInStackTrace",
"JVM_FillInStackTrace",
"java_lang_Throwable::fill_in_stack_trace(Handle, methodHandle)",
"Method::bci_from(unsigned char*) const",
"user$eval$fn__.invoke",
"clj-async-profiler.core/stop",
"clj-async-profiler.core/status",
"fileOpen",
"fstat",
"clojure.core/reduce",
"clojure.core/+'",
"clojure.lang.Numbers.addP",
"clojure.lang.Numbers$LongOps.addP",
"clojure.lang.Numbers.num",
"java.lang.Long.valueOf",
"clojure.lang.LongRange.reduce",
"clojure.core/*'",
"clojure.lang.Numbers.multiplyP",
"clojure.lang.Numbers$OpsP.multiplyP",
"clojure.lang.Numbers$BigIntOps.multiply",
"clojure.lang.BigInt.multiply",
"clojure.lang.BigInt.toBigInteger",
"java.math.BigInteger.valueOf",
"java.math.BigInteger.multiply",
"java.math.BigInteger.multiplyByInt",
"OptoRuntime::new_array_C(Klass*, int, JavaThread*)",
"_platform_memset",
"jint_disjoint_arraycopy",
"OptoRuntime::new_instance_C(Klass*, JavaThread*)",
"InstanceKlass::allocate_instance(Thread*)",
"post_allocation_notify(KlassHandle, oopDesc*, int)",
"JfrAllocationTracer::~JfrAllocationTracer()",
"clojure.core//",
"clojure.lang.Numbers.divide",
"clojure.lang.Numbers$RatioOps.divide",
"java.math.BigInteger.divide",
"java.math.BigInteger.divideKnuth",
"java.math.MutableBigInteger.divideKnuth",
"arrayof_jint_fill",
"java.math.MutableBigInteger.divideOneWord",
"java.math.BigInteger.gcd",
"java.math.MutableBigInteger.hybridGCD",
"arrayof_jlong_disjoint_arraycopy",
"java.math.MutableBigInteger.divide",
"java.math.MutableBigInteger.getLowestSetBit",
"java.math.MutableBigInteger.toBigInteger",
"OptoRuntime::new_array_nozero_C(Klass*, int, JavaThread*)",
"TypeArrayKlass::allocate_common(int, bool, Thread*)",
"CollectedHeap::common_mem_allocate_noinit(KlassHandle, unsigned long, Thread*)",
"ParallelScavengeHeap::mem_allocate(unsigned long, bool*)",
"VMThread::execute(VM_Operation*)",
"Monitor::wait(bool, long, bool)",
"Monitor::IWait(Thread*, long)",
"ParkCommon(ParkEvent*, long)",
"os::PlatformEvent::park()",
"__psynch_cvwait",
"AllocTracer::send_allocation_in_new_tlab_event(KlassHandle, HeapWord*, unsigned long, unsigned long, Thread*)",
"JfrAllocationTracer::JfrAllocationTracer(HeapWord*, unsigned long, Thread*)",
"java.math.BigInteger.multiplyKaratsuba",
"itable stub",
"java.lang.Thread.run",
"sun.net.httpserver.ServerImpl$Dispatcher.run",
"thread_start",
"_pthread_start",
"java_start(Thread*)",
"GCTaskThread::run()",
"GCTaskManager::get_task(unsigned int)",
"Monitor::lock_without_safepoint_check()",
"Monitor::ILock(Thread*)",
"GCTaskManager::note_completion(unsigned int)",
"OldToYoungRootsTask::do_it(GCTaskManager*, unsigned int)",
"CardTableExtension::scavenge_contents_parallel(ObjectStartArray*, MutableSpace*, HeapWord*, PSPromotionManager*, unsigned int, unsigned int)",
"ObjectStartArray::object_start(HeapWord*) const",
"ScavengeRootsTask::do_it(GCTaskManager*, unsigned int)",
"ClassLoaderDataGraph::oops_do(OopClosure*, KlassClosure*, bool)",
"ClassLoaderData::oops_do(OopClosure*, KlassClosure*, bool)",
"PSScavengeKlassClosure::do_klass(Klass*)",
"StealTask::do_it(GCTaskManager*, unsigned int)",
"ParallelTaskTerminator::offer_termination(TerminatorTerminator*)",
"swtch_pri",
"SpinPause",
"WaitForBarrierGCTask::do_it(GCTaskManager*, unsigned int)",
"JavaThread::run()",
"JavaThread::thread_main_inner()",
"CompileBroker::compiler_thread_loop()",
"CompileBroker::invoke_compiler_on_method(CompileTask*)",
"C2Compiler::compile_method(ciEnv*, ciMethod*, int)",
"Compile::Compile(ciEnv*, C2Compiler*, ciMethod*, int, bool, bool, bool)",
"Compile::Code_Gen()",
"Compile::Output()",
"Compile::BuildOopMaps()",
"OopFlow::compute_reach(PhaseRegAlloc*, int, Dict*)",
"Compile::ScheduleAndBundle()",
"ShouldNotReachHereNode::ideal_Opcode() const",
"Compile::init_buffer(unsigned int*)",
"Compile::shorten_branches(unsigned int*, int&, int&, int&)",
"Compile::scratch_emit_size(Node const*)",
"CodeBuffer::CodeBuffer(unsigned char*, int)",
"CodeBuffer::verify_section_allocation()",
"Compile::fill_buffer(CodeBuffer*, unsigned int*)",
"Compile::Process_OopMap_Node(MachNode*, int)",
"DebugInformationRecorder::create_scope_values(GrowableArray<ScopeValue*>*)",
"DebugInformationRecorder::serialize_scope_values(GrowableArray<ScopeValue*>*)",
"NonSafepointEmitter::observe_instruction(Node*, int)",
"NonSafepointEmitter::emit_non_safepoint()",
"CompressedWriteStream::write_int(int)",
"DebugInformationRecorder::describe_scope(int, ciMethod*, int, bool, bool, bool, DebugToken*, DebugToken*, DebugToken*)",
"NonSafepointEmitter::observe_safepoint(JVMState*, int)",
"DebugInformationRecorder::find_sharable_decode_offset(int)",
"DIR_Chunk::find_match(GrowableArray<DIR_Chunk*>*, int, DebugInformationRecorder*)",
"Matcher::match()",
"Arena::contains(void const*) const",
"Matcher::find_shared(Node*)",
"Matcher::xform(Node*, int)",
"Matcher::match_sfpt(SafePointNode*)",
"Matcher::match_tree(Node const*)",
"Matcher::ReduceInst(State*, int, Node*&)",
"Arena::Amalloc_D(unsigned long, AllocFailStrategy::AllocFailEnum)",
"State::MachNodeGenerator(int, Compile*)",
"Arena::grow(unsigned long, AllocFailStrategy::AllocFailEnum)",
"ChunkPool::allocate(unsigned long, AllocFailStrategy::AllocFailEnum)",
"os::malloc(unsigned long, MemoryType, NativeCallStack const&)",
"_malloc_zone_malloc",
"szone_malloc_should_clear",
"small_malloc_should_clear",
"small_malloc_from_free_list",
"small_free_list_add_ptr",
"Node::clone() const",
"PhaseCFG::do_global_code_motion()",
"PhaseCFG::estimate_block_frequency()",
"CFGLoop::compute_freq()",
"Block::succ_prob(unsigned int)",
"PhaseCFG::global_code_motion()",
"PhaseCFG::compute_latencies_backwards(VectorSet&, Node_List&)",
"PhaseCFG::partial_latency_of_defs(Node*)",
"GrowableArray<unsigned int>::at_grow(int, unsigned int const&)",
"PhaseCFG::implicit_null_check(Block*, Node*, Node*, int)",
"Dict::Insert(void*, void*, bool)",
"PhaseCFG::schedule_late(VectorSet&, Node_List&)",
"Node_Backward_Iterator::next()",
"PhaseCFG::schedule_pinned_nodes(VectorSet&)",
"PhaseCFG::remove_empty_blocks()",
"PhaseCFG::move_to_end(Block*, unsigned int)",
"PhaseChaitin::Register_Allocate()",
"CProjNode::is_block_proj() const",
"IndexSetIterator::next()",
"MachNode::in_RegMask(unsigned int) const",
"MachNode::oper_input_base() const",
"Node::jvms() const",
"Node::rematerialize() const",
"PhaseAggressiveCoalesce::insert_copies(Matcher&)",
"PhaseChaitin::Select()",
"IndexSetIterator::advance_and_next()",
"PhaseIFG::re_insert(unsigned int)",
"PhaseChaitin::Simplify()",
"PhaseChaitin::Split(unsigned int, ResourceArea*)",
"MachNode::rematerialize() const",
"PhaseChaitin::build_ifg_physical(ResourceArea*)",
"IndexSet::insert(unsigned int)",
"IndexSet::alloc_block_containing(unsigned int)",
"ThreadLocalStorage::is_initialized()",
"PhaseChaitin::interfere_with_live(unsigned int, IndexSet*)",
"PhaseChaitin::build_ifg_virtual()",
"RegMask::overlap(RegMask const&) const",
"PhaseChaitin::gather_lrg_masks(bool)",
"RegMask::Size() const",
"PhaseChaitin::merge_multidefs()",
"PhaseChaitin::post_allocate_copy_removal()",
"PhaseChaitin::elide_copy(Node*, int, Block*, Node_List&, Node_List&, bool)",
"find_lowest_bit(unsigned int)",
"PhaseChaitin::stretch_base_pointer_live_ranges(ResourceArea*)",
"IndexSet::IndexSet(IndexSet*)",
"PhaseCoalesce::coalesce_driver()",
"PhaseConservativeCoalesce::coalesce(Block*)",
"PhaseConservativeCoalesce::copy_copy(Node*, Node*, Block*, unsigned int)",
"PhaseConservativeCoalesce::update_ifg(unsigned int, unsigned int, IndexSet*, IndexSet*)",
"PhaseIFG::SquareUp()",
"IndexSet::alloc_block()",
"PhaseLive::compute(unsigned int)",
"IndexSet::clear()",
"IndexSet::free_block(unsigned int)",
"IndexSet::initialize(unsigned int)",
"PhaseLive::add_liveout(Block*, IndexSet*, VectorSet&)",
"RegMask::AND(RegMask const&)",
"iRegNOper::in_RegMask(int) const",
"Compile::Optimize()",
"Compile::final_graph_reshaping()",
"Compile::final_graph_reshaping_walk(Node_Stack&, Node*, Final_Reshape_Counts&)",
"ConnectionGraph::do_analysis(Compile*, PhaseIterGVN*)",
"ConnectionGraph::compute_escape()",
"CheckCastPPNode::Opcode() const",
"ConnectionGraph::add_call_node(CallNode*)",
"ciMethod::get_bcea()",
"BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod*, BCEscapeAnalyzer*)",
"ciMethod::method_data()",
"ciMethodData::load_data()",
"SimpleThresholdPolicy::is_mature(Method*)",
"ConnectionGraph::split_unique_types(GrowableArray<Node*>&)",
"PhaseIterGVN::add_users_to_worklist(Node*)",
"Unique_Node_List::push(Node*)",
"PhaseCCP::PhaseCCP(PhaseIterGVN*)",
"PhaseCCP::analyze()",
"Unique_Node_List::pop()",
"PhaseCCP::do_transform()",
"PhaseCCP::transform(Node*)",
"PhaseIdealLoop::PhaseIdealLoop(PhaseIterGVN&, bool, bool)",
"PhaseIdealLoop::build_and_optimize(bool, bool)",
"CProjNode::is_CFG() const",
"IdealLoopTree::check_safepts(VectorSet&, Node_List&)",
"IdealLoopTree::counted_loop(PhaseIdealLoop*)",
"PhaseTransform::intcon(int)",
"IdealLoopTree::iteration_split(PhaseIdealLoop*, Node_List&)",
"PhaseIdealLoop::do_unswitching(IdealLoopTree*, Node_List&)",
"PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree*, Node_List&)",
"PhaseIdealLoop::clone_loop(IdealLoopTree*, Node_List&, int, Node*)",
"IdealLoopTree::loop_predication(PhaseIdealLoop*)",
"PhaseIdealLoop::loop_predication_impl(IdealLoopTree*)",
"Invariance::clone(Node*, Node*)",
"Invariance::clone_nodes(Node*, Node*)",
"Invariance::clone_visit(Node*)",
"Node_Array::grow(unsigned int)",
"Arena::Arealloc(void*, unsigned long, unsigned long, AllocFailStrategy::AllocFailEnum)",
"IdealLoopTree::reassociate_invariants(PhaseIdealLoop*)",
"IdealLoopTree::reassociate_add_sub(Node*, PhaseIdealLoop*)",
"PhaseIdealLoop::Dominators()",
"MultiNode::is_CFG() const",
"NTarjan::DFS(NTarjan*, VectorSet&, PhaseIdealLoop*, unsigned int*)",
"NTarjan::setdepth(unsigned int, unsigned int*)",
"RegionNode::is_CFG() const",
"PhaseIdealLoop::build_loop_early(VectorSet&, Node_List&, Node_Stack&)",
"PhaseIdealLoop::set_early_ctrl(Node*)",
"PhaseIdealLoop::get_early_ctrl(Node*)",
"PhaseIdealLoop::get_ctrl_no_update(Node*) const",
"PhaseIdealLoop::build_loop_late(VectorSet&, Node_List&, Node_Stack&)",
"PhaseIdealLoop::build_loop_late_post(Node*)",
"PhaseIdealLoop::get_late_ctrl(Node*, Node*)",
"PhaseIdealLoop::compute_lca_of_uses(Node*, Node*, bool)",
"PhaseIdealLoop::dom_lca_for_get_late_ctrl(Node*, Node*, Node*)",
"PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal(Node*, Node*, Node*)",
"PhaseIdealLoop::dom_depth(Node*) const",
"PhaseIdealLoop::is_dominator(Node*, Node*)",
"PhaseIdealLoop::build_loop_tree()",
"PhaseIdealLoop::split_if_with_blocks(VectorSet&, Node_Stack&)",
"PhaseIdealLoop::has_local_phi_input(Node*)",
"PhaseIdealLoop::split_if_with_blocks_post(Node*)",
"PhaseIterGVN::subsume_node(Node*, Node*)",
"PhaseIterGVN::remove_globally_dead_node(Node*)",
"Unique_Node_List::remove(Node*)",
"PhaseIdealLoop::split_if_with_blocks_pre(Node*)",
"PhaseIdealLoop::has_node(Node*) const",
"PhaseIdealLoop::split_thru_phi(Node*, Node*, int)",
"AddPNode::Identity(PhaseTransform*)",
"Type::hashcons()",
"PhiNode::make_blank(Node*, Node*)",
"PhiNode::PhiNode(Node*, Type const*, TypePtr const*, int, int, int, int)",
"PhaseIterGVN::optimize()",
"PhaseIterGVN::transform_old(Node*)",
"CallNode::Ideal(PhaseGVN*, bool)",
"Node::remove_dead_region(PhaseGVN*, bool)",
"LoadNode::Value(PhaseTransform*) const",
"AllocateNode::Ideal_allocation(Node*, PhaseTransform*)",
"RegionNode::Ideal(PhaseGVN*, bool)",
"RegionNode::is_unreachable_region(PhaseGVN*) const",
"ProjNode::is_CFG() const",
"ProjNode::pinned() const",
"RethrowNode::is_CFG() const",
"SuperWord::SLP_extract()",
"SuperWord::find_adjacent_refs()",
"SuperWord::same_velt_type(Node*, Node*)",
"PhaseIterGVN::PhaseIterGVN(PhaseGVN*)",
"ConstraintCastNode::Identity(PhaseTransform*)",
"TypeOopPtr::xmeet(Type const*) const",
"TypeInstPtr::xmeet_helper(Type const*) const",
"MergeMemNode::Ideal(PhaseGVN*, bool)",
"MultiNode::hash() const",
"Node::set_req(unsigned int, Node*)",
"PhaseMacroExpand::expand_macro_nodes()",
"PhaseMacroExpand::expand_unlock_node(UnlockNode*)",
"Type::cmp(Type const*, Type const*)",
"PhaseRenumberLive::PhaseRenumberLive(PhaseGVN*, Unique_Node_List*, Unique_Node_List*, Phase::PhaseNumber)",
"PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN*, Unique_Node_List*, Phase::PhaseNumber)",
"Compile::identify_useful_nodes(Unique_Node_List&)",
"Compile::inline_string_calls(bool)",
"Compile::remove_useless_nodes(Unique_Node_List&)",
"ParseGenerator::generate(JVMState*)",
"Parse::Parse(JVMState*, ciMethod*, float)",
"Parse::do_all_blocks()",
"Parse::do_one_block()",
"Parse::do_call()",
"Compile::call_generator(ciMethod*, int, bool, JVMState*, bool, float, ciKlass*, bool, bool)",
"InlineTree::ok_to_inline(ciMethod*, JVMState*, ciCallProfile&, WarmCallInfo*, bool&)",
"InlineTree::check_can_parse(ciMethod*)",
"ciMethod::get_flow_analysis()",
"ciTypeFlow::do_flow()",
"ciTypeFlow::flow_types()",
"ciTypeFlow::df_flow_types(ciTypeFlow::Block*, bool, ciTypeFlow::StateVector*, ciTypeFlow::JsrSet*)",
"ciTypeFlow::flow_block(ciTypeFlow::Block*, ciTypeFlow::StateVector*, ciTypeFlow::JsrSet*)",
"ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream*)",
"ciTypeFlow::StateVector::do_invoke(ciBytecodeStream*, bool)",
"ciBytecodeStream::get_method(bool&, ciSignature**)",
"ciEnv::get_method_by_index(constantPoolHandle, int, Bytecodes::Code, ciInstanceKlass*)",
"ciEnv::get_method_by_index_impl(constantPoolHandle, int, Bytecodes::Code, ciInstanceKlass*)",
"ciObjectFactory::get_metadata(Metadata*)",
"ciObjectFactory::create_new_metadata(Metadata*)",
"ciMethod::ciMethod(methodHandle, ciInstanceKlass*)",
"ciSignature::ciSignature(ciKlass*, constantPoolHandle, ciSymbol*)",
"SymbolTable::lookup(int, char const*, int, unsigned int)",
"ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream*)",
"ciBytecodeStream::get_field(bool&)",
"ciEnv::get_field_by_index(ciInstanceKlass*, int)",
"ciEnv::get_field_by_index_impl(ciInstanceKlass*, int)",
"ciField::ciField(ciInstanceKlass*, int)",
"vmSymbols::find_sid(Symbol*)",
"ciEnv::lookup_method(InstanceKlass*, InstanceKlass*, Symbol*, Symbol*, Bytecodes::Code)",
"LinkResolver::resolve_static_call_or_null(KlassHandle, Symbol*, Symbol*, KlassHandle, bool)",
"LinkResolver::resolve_static_call(CallInfo&, KlassHandle&, Symbol*, Symbol*, KlassHandle, bool, bool, Thread*)",
"CallInfo::set_static(KlassHandle, methodHandle, Thread*)",
"CallInfo::set_common(KlassHandle, KlassHandle, methodHandle, methodHandle, CallInfo::CallKind, int, Thread*)",
"ciEnv::register_method(ciMethod*, int, CodeOffsets*, int, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, int, bool, bool, RTMState)",
"nmethod::new_nmethod(methodHandle, int, int, CodeOffsets*, int, DebugInformationRecorder*, Dependencies*, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, int)",
"nmethod::nmethod(Method*, int, int, int, CodeOffsets*, int, DebugInformationRecorder*, Dependencies*, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, int)",
"CodeBlob::CodeBlob(char const*, CodeBuffer*, int, int, int, int, OopMapSet*)",
"CodeBuffer::copy_code_to(CodeBlob*)",
"CodeBuffer::relocate_code_to(CodeBuffer*) const",
"CallRelocation::fix_relocation_after_move(CodeBuffer const*, CodeBuffer*)",
"Relocation::pd_call_destination(unsigned char*)",
"trampoline_stub_Relocation::get_trampoline_for(unsigned char*, nmethod*)",
"RelocIterator::next()",
"Relocation::pd_set_call_destination(unsigned char*)",
"Compiler::compile_method(ciEnv*, ciMethod*, int)",
"Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*)",
"Compilation::compile_method()",
"Compilation::compile_java_method()",
"Compilation::build_hir()",
"IR::IR(Compilation*, ciMethod*, int)",
"IRScope::IRScope(Compilation*, IRScope*, int, ciMethod*, int, bool)",
"GraphBuilder::GraphBuilder(Compilation*, IRScope*)",
"GraphBuilder::iterate_all_blocks(bool)",
"GraphBuilder::iterate_bytecodes_for_block(int)",
"GraphBuilder::invoke(Bytecodes::Code)",
"GraphBuilder::try_inline(ciMethod*, bool, Bytecodes::Code, Instruction*)",
"GraphBuilder::try_inline_full(ciMethod*, bool, Bytecodes::Code, Instruction*)",
"GraphBuilder::method_return(Instruction*)",
"CompileQueue::get()",
"NMethodSweeper::possibly_sweep()",
"NMethodSweeper::sweep_code_cache()",
"NMethodSweeper::process_nmethod(nmethod*)",
"nmethod::cleanup_inline_caches()",
"attach_listener_thread_entry(JavaThread*, Thread*)",
"JvmtiExport::load_agent_library(AttachOperation*, outputStream*)",
"Agent_OnAttach",
"Profiler::run(Arguments&)",
"std::__::basic_ofstream<char, std::__::char_traits<char> >::basic_ofstream(char const*, unsigned int)",
"fopen$DARWIN_EXTSN",
"__open_nocancel",
"VMThread::run()",
"VMThread::loop()",
"EventMark::~EventMark()",
"Events::log(Thread*, char const*, ...)",
"StringEventLog::logv(Thread*, char const*, char*)",
"jio_vsnprintf",
"os::vsnprintf(char*, unsigned long, char const*, char*)",
"_vsnprintf",
"__vfprintf",
"os::PlatformEvent::park(long)",
"VMThread::evaluate_operation(VM_Operation*)",
"VM_Operation::evaluate()",
"VM_ParallelGCFailedAllocation::doit()",
"ParallelScavengeHeap::failed_mem_allocate(unsigned long)",
"PSScavenge::invoke()",
"PSScavenge::invoke_no_policy()",
"MetaspaceAux::print_on(outputStream*)",
"StringTable::unlink_or_oops_do(BoolObjectClosure*, OopClosure*, int*, int*)",
"StringTable::buckets_unlink_or_oops_do(BoolObjectClosure*, OopClosure*, int, int, BasicHashtable<(MemoryType)9>::BucketUnlinkContext*)",
"WatcherThread::run()",
"PeriodicTask::real_time_tick(int)",
"PerfLongVariant::sample()",
"StatSampler::collect_sample()",
"os::elapsed_counter()",
"mach_absolute_time",
"StatSamplerTask::task()",
"WatcherThread::sleep() const",
"_pthread_cond_wait",
"__gettimeofday",
];
var initialStacks = [];
var stacks;

var _lastInsertedStack = null;

function a(frameIds, samples) {
  var same = frameIds[0];
  var frames = (same > 0) ? _lastInsertedStack.slice(0,same) : [];

  for (var i = 1, len = frameIds.length; i < len; i++) {
    frames.push(idToFrame[frameIds[i]]);
  }

  _lastInsertedStack = frames;
  initialStacks.push({stackStr: frames.join(";"), samples: samples});
}

var totalSamplesA = 0, totalSamplesB = 0;

function d(frameIds, samples_a, samples_b) {
  var same = frameIds[0];
  var frames = (same > 0) ? _lastInsertedStack.slice(0,same) : [];

  for (var i = 1, len = frameIds.length; i < len; i++) {
    frames.push(idToFrame[frameIds[i]]);
  }

  totalSamplesA += samples_a;
  totalSamplesB += samples_b;

  _lastInsertedStack = frames;
  initialStacks.push({stackStr: frames.join(";"),
                      samples_a: samples_a, samples_b: samples_b});
}

function _extractRegexPrefix(s) {
  let parsed = s.match(/^\/\.\+(.+)\/g$/);
  if (parsed != null) {
    return new RegExp(parsed[1], 'g');
  }
}

function _stringToMaybeRegex(s) {
  if (s == null) return null;
  let parsed = s.match(/^\/(.+)\/$/);
  if (parsed != null)
    return new RegExp(parsed[1], 'g');
  else
    return s;
}

function _makeTransform(type, enabled, what, replacement) {
  let what2 = (typeof(what) == 'string') ? _stringToMaybeRegex(what) : what;
  let what2Str = what2.toString();
  let prefix = (what2 instanceof RegExp) ?
      _extractRegexPrefix(what2Str) : null;
  if (type == 'replace')
    return { type: type, enabled: enabled, what: what2, replacement: replacement, prefix: prefix}
  else
    return { type: type, enabled: enabled, what: what2}
}

var userTransforms = [];

function match(string, obj) {
  if (typeof(obj) == 'string') {
    return string.includes(obj);
  } else
    return string.match(obj);
}

function applyReplacement(string, what, replacement, prefix) {
  var s = string;
  var prevMatch = null;
  if (prefix != null) {
    while (true) {
      let match = prefix.exec(string);
      if (match == null) {
        if (prevMatch == null)
          return s;
        else {
          s = string.substring(Math.max(prevMatch.index, 0));
          return s.replace(prefix, replacement);
        }
      } else {
        prevMatch = match;
      }
    }
  }
  return s.replaceAll(what, replacement);
}

function transformStacks() {
  console.time("transformStacks");
  let diff = isDiffgraph;
  var result;
  if (userTransforms.length > 0) {
    var xformedMap = {};
    for (var i = 0; i < initialStacks.length; i++) {
      var stack = initialStacks[i];
      var xformedStr = ";" + stack.stackStr + ";";
      var useIt = true;

      for (var t = 0; t < userTransforms.length; t++) {
        const transform = userTransforms[t];
        if (transform.enabled && transform.what != '') {
          if (transform.type == 'replace') {
            xformedStr = applyReplacement(xformedStr, transform.what,
                                          transform.replacement, transform.prefix);
          } else if (transform.type == 'filter') {
            if (!match(xformedStr, transform.what))
              useIt = false;
          } else if (transform.type == 'remove') {
            if (match(xformedStr, transform.what))
              useIt = false;
          }
        }
        if (!useIt) break;
      }

      xformedStr = xformedStr.substring(1,xformedStr.length-1);

      if (useIt)
        if (diff) {
          let newVal = (xformedMap[xformedStr] || {});
          newVal.samples_a = (newVal.samples_a || 0) + stack.samples_a;
          newVal.samples_b = (newVal.samples_b || 0) + stack.samples_b;
          xformedMap[xformedStr] = newVal;
        } else
          xformedMap[xformedStr] = stack.samples + (xformedMap[xformedStr] || 0);
    }

    var xformedStacks = [];
    for (xformedStr in xformedMap) {
      if (diff) {
        let val = xformedMap[xformedStr];
        xformedStacks.push({stackStr: xformedStr, samples_a: val.samples_a, samples_b: val.samples_b})
      } else
        xformedStacks.push({stackStr: xformedStr, samples: xformedMap[xformedStr]});
    }
    result = xformedStacks;
  } else
    result = initialStacks;

  console.timeEnd("transformStacks");
  return result;
}

console.time("data exec time");

  d([0,0,1,],76,11);
d([1,2,],57,9);
d([0,3,4,5,6,7,8,9,10,11,12,13,14,15,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,],1,0);
d([16,30,31,32,33,34,35,36,37,38,39,40,41,42,],1,0);
d([17,43,7,44,45,5,6,7,46,47,48,47,48,49,50,51,52,53,54,55,56,56,57,58,59,60,],0,1);
d([16,61,62,63,7,44,45,5,6,7,46,47,48,47,48,49,50,51,64,65,],1,0);
d([17,66,67,68,69,70,71,],0,5);
d([18,72,],81,121);
d([19,73,74,75,76,77,78,79,],1,0);
d([24,80,80,81,],757,0);
d([27,82,83,],1,0);
d([27,84,],1,0);
d([19,67,],25,47);
d([20,68,85,86,87,88,],1,0);
d([21,69,70,71,],192,361);
d([19,89,90,91,90,92,93,],3,4);
d([25,94,],3,1);
d([26,95,],1,0);
d([26,96,],659,358);
d([23,97,98,],3,0);
d([25,99,],1,2);
d([25,100,100,94,96,],693,343);
d([28,101,],1,0);
d([24,102,103,104,105,106,107,108,109,110,111,112,],1,0);
d([23,80,],1,0);
d([22,80,],2,0);
d([23,80,81,],197,82);
d([25,82,104,87,113,114,],1,0);
d([24,115,],4,0);
d([19,116,],177,241);
d([19,71,],85,148);
d([0,117,118,],1,0);
d([0,119,120,121,122,123,124,125,],1,0);
d([5,108,109,110,111,112,],9,1);
d([4,126,124,125,110,111,112,],1,0);
d([4,127,128,],2,2);
d([6,129,],2,0);
d([4,130,131,132,],8,4);
d([7,133,],2,0);
d([4,134,135,],45,19);
d([6,136,],21,10);
d([5,137,],5,3);
d([4,138,108,109,110,111,112,],0,2);
d([3,139,140,141,142,143,144,145,146,147,],1,0);
d([12,148,],0,1);
d([11,149,150,],0,1);
d([11,151,152,153,154,155,],1,0);
d([10,156,157,158,159,],0,1);
d([11,160,161,162,],1,0);
d([13,163,],0,1);
d([11,164,161,163,165,166,],1,0);
d([10,167,168,],1,1);
d([11,169,],1,0);
d([11,170,],0,1);
d([12,171,],1,0);
d([12,172,173,174,],1,0);
d([14,175,176,177,178,179,180,181,182,183,],0,1);
d([12,184,],0,1);
d([10,185,186,187,188,],1,0);
d([11,189,190,191,],1,0);
d([14,192,],0,1);
d([12,193,194,],0,1);
d([12,195,196,],1,0);
d([12,197,],0,1);
d([10,198,199,],0,1);
d([10,200,201,],1,0);
d([11,202,],0,1);
d([11,203,],0,1);
d([11,204,],1,0);
d([11,205,],0,1);
d([11,206,],1,1);
d([11,207,],2,2);
d([11,208,209,],0,1);
d([12,210,209,],0,1);
d([11,211,209,],1,0);
d([11,212,],3,5);
d([12,213,],0,1);
d([11,214,],1,1);
d([12,215,],1,0);
d([13,216,217,],1,0);
d([12,218,209,],0,3);
d([11,219,215,],0,1);
d([12,220,],1,0);
d([11,221,],1,1);
d([12,222,],1,0);
d([11,223,],1,0);
d([11,224,225,],1,2);
d([12,226,],1,0);
d([11,227,228,],1,0);
d([11,229,230,231,232,209,],1,0);
d([11,233,215,234,],0,1);
d([11,235,236,],1,0);
d([12,237,],0,1);
d([12,238,],0,2);
d([12,239,209,],1,0);
d([11,240,],0,1);
d([11,222,],1,0);
d([11,241,],0,1);
d([9,242,243,244,],0,1);
d([10,245,246,247,],0,1);
d([12,248,249,250,251,252,253,],1,0);
d([12,254,255,256,83,],1,0);
d([10,257,258,],1,0);
d([12,259,],0,1);
d([10,260,261,],0,1);
d([10,262,263,264,],1,0);
d([12,265,265,265,265,265,],0,1);
d([17,265,265,265,265,265,265,265,265,265,265,],0,1);
d([12,266,266,267,],1,0);
d([12,268,268,268,268,268,268,268,269,270,271,],0,1);
d([12,272,272,272,272,272,272,272,272,272,273,274,275,276,277,278,176,],0,1);
d([12,279,280,],0,1);
d([12,281,282,],0,1);
d([13,283,],1,0);
d([13,284,],0,1);
d([13,285,],1,0);
d([12,286,],0,3);
d([13,287,288,],1,0);
d([15,289,],1,0);
d([12,290,],1,1);
d([13,291,],2,1);
d([14,292,],3,1);
d([15,293,294,295,],1,0);
d([15,296,],2,0);
d([15,297,],1,0);
d([12,298,],0,1);
d([12,299,],0,1);
d([13,300,],0,1);
d([13,301,],0,1);
d([14,302,303,304,],0,1);
d([13,305,306,],1,0);
d([14,307,308,309,194,],1,0);
d([15,303,],1,0);
d([15,310,311,83,],0,1);
d([12,312,313,314,315,],1,0);
d([14,316,317,],0,1);
d([14,318,319,],0,1);
d([12,320,],1,0);
d([12,321,],1,0);
d([12,285,],0,1);
d([12,322,],1,0);
d([12,323,324,325,],1,0);
d([10,326,],0,1);
d([10,312,],1,0);
d([11,313,327,328,329,309,194,],0,1);
d([12,330,],1,0);
d([12,331,],1,0);
d([12,302,303,332,],1,0);
d([12,318,282,],0,1);
d([13,302,303,304,],0,1);
d([13,320,],0,1);
d([10,333,334,309,194,335,],1,0);
d([10,336,337,338,],1,0);
d([12,256,],0,1);
d([9,339,337,340,],0,1);
d([9,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,27,28,363,],0,1);
d([14,341,342,343,344,345,341,342,343,344,345,341,342,343,344,345,341,342,343,344,345,346,347,348,349,350,351,352,353,354,364,365,366,367,368,369,],0,1);
d([24,356,357,358,370,371,372,373,374,],0,1);
d([9,375,376,377,378,379,380,381,382,383,384,],0,1);
d([15,385,383,384,],1,0);
d([7,386,387,388,389,390,391,392,393,394,395,396,397,398,394,395,396,397,398,394,395,396,397,398,394,395,396,397,398,394,395,399,],0,1);
d([6,400,401,402,403,],0,1);
d([10,404,384,],1,0);
d([5,405,406,407,408,409,410,411,],0,2);
d([3,412,413,414,415,416,417,418,419,420,],1,0);
d([5,108,109,421,112,],0,1);
d([5,422,423,424,425,426,427,428,],1,0);
d([11,429,430,],7,3);
d([3,431,432,],1,0);
d([5,433,],1,0);
d([5,434,433,435,436,],1,0);
d([4,437,],1,0);
d([4,438,108,109,439,],1,0);
d([7,421,440,],1,1);
d([8,112,],12,4);
d([8,439,],1,1);


console.timeEnd("data exec time");


function makeTreeNode() {
  if (isDiffgraph)
    return {self_samples_a: 0, self_samples_b: 0, self_delta: 0,
            total_samples_a: 0, total_samples_b: 0, total_delta: 0,
            delta_abs: 0, children: {}};
  else
    return {self: 0, total: 0, children: {}};
}

function getChildNode(node, childTitle) {
  var children = node.children;
  var child = children[childTitle];
  if (child == undefined) {
    child = makeTreeNode();
    children[childTitle] = child;
  }
  return child;
}

function parseStacksToTreeSimple(stacks, treeRoot) {
  console.time("parseStacksToTreeSimple");
  var depth = 0;
  for (var i = 0, len = stacks.length; i < len; i++) {
    var stack = stacks[i];
    var stackframes = stack.stackStr.split(";");
    var stackLen = stackframes.length;
    depth = Math.max(depth, stackLen);
    var node = treeRoot;
    if (reverseGraph) {
      for (var j = stackLen-1; j >= 0; j--) {
        var stackframe = stackframes[j];
        node.total += stack.samples;
        node = getChildNode(node, stackframe);
      }
    } else {
      for (var j = 0; j < stackLen; j++) {
        var stackframe = stackframes[j];
        node.total += stack.samples;
        node = getChildNode(node, stackframe);
      }
    }
    node.total += stack.samples;
    node.self += stack.samples;
  }
  console.timeEnd("parseStacksToTreeSimple");
  return depth;
}

function parseStacksToTreeDiffgraph(stacks, treeRoot) {
  console.time("parseStacksToTreeDiffgraph");
  var depth = 0;

  for (var i = 0, len = stacks.length; i < len; i++) {
    var stack = stacks[i];
    var stackframes = stack.stackStr.split(";");
    var stackLen = stackframes.length;
    depth = Math.max(depth, stackLen);
    var node = treeRoot;

    var samplesA = stack.samples_a;
    var samplesB = stack.samples_b;
    if (normalizeDiff) samplesB = Math.round(samplesB * b_scale_factor);
    var delta = samplesB - samplesA;


    if (reverseGraph) {
      for (var j = stackLen-1; j >= 0; j--) {
        var stackframe = stackframes[j];
        node.total_samples_a += samplesA;
        node.total_samples_b += samplesB;
        node.total_delta += delta;
        node.delta_abs += Math.abs(delta);
        node = getChildNode(node, stackframe);
      }
    } else {
      for (var j = 0; j < stackLen; j++) {
        var stackframe = stackframes[j];
        node.total_samples_a += samplesA;
        node.total_samples_b += samplesB;
        node.total_delta += delta;
        node.delta_abs += Math.abs(delta);
        node = getChildNode(node, stackframe);
      }
    }
    node.self_samples_a += samplesA;
    node.self_samples_b += samplesB;
    node.self_delta += delta;
    node.total_samples_a += samplesA;
    node.total_samples_b += samplesB;
    node.total_delta += delta;
    node.delta_abs += Math.abs(delta);
  }
  console.timeEnd("parseStacksToTreeDiffgraph");
  return depth;
}

function parseStacksToTree(stacks, treeRoot) {
  if (isDiffgraph)
    return parseStacksToTreeDiffgraph(stacks, treeRoot);
  else
    return parseStacksToTreeSimple(stacks, treeRoot);
}

const palette = {
  green: "#50e150",
  aqua: "#50bebe",
  orange: "#e17d00",
  yellow: "#c8c83c",
  red: "#e15a5a",
  clojure_green: "#91dc51",
  clojure_blue: "#8fb5fe",
};

function getColor(title) {
  if (title.endsWith("_[j]")) {
    return palette.green;
  } else if (title.endsWith("_[i]")) {
    return palette.aqua;
  } else if (title.endsWith("_[k]")) {
    return palette.orange;
  } else if (title.includes("::") || title.startsWith("-[") || title.startsWith("+[")) {
    return palette.yellow;
  } else if (title.includes("/")) { // Clojure (will only work after unmunging)
    return palette.clojure_blue;
  } else if (title.includes(".")) { // Java (if it has a dot and is not Clojure)
    return palette.clojure_green;
  } else return palette.red;
}

function decToHex(n) {
  var hex = n.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}

function getDiffColor(isRed, intensity) {
  return "hsl(" + ((isRed) ? 0 : 220) + ",100%," + Math.round(90 - intensity * 30) + "%)";
  // return "hsl(" + ((isRed) ? 0 : 220) + "," + Math.round(100 * intensity) + "%, 60%)";
}

function scaleColorMap(colorMap, intensity) {
  return '#' + decToHex(intensity * colorMap.red) +
    decToHex(intensity * colorMap.green) + decToHex(intensity * colorMap.blue);
}

var stacks, tree, levels, depth;

var smallestPixelsPerSample, minPixelsPerFrame = 0.25, minSamplesToShow;

function generateLevelsSimple(levels, node, title, level, x, minSamplesToShow) {
  var left = x;

  levels[level] = levels[level] || [];
  if (node.total >= minSamplesToShow) {
    levels[level].push({left: left, width: node.total, color: getColor(title),
                        title: title});

    left += node.self;

    let children = Object.entries(node.children);
    if (sortByNameRadio.checked)
      children.sort((a, b) => a[0].localeCompare(b[0]));
    else
      children.sort((a, b) => b[1].total - a[1].total);

    for (let i in children) {
      let title = children[i][0];
      let child = children[i][1];
      generateLevelsSimple(levels, child, title, level+1, left, minSamplesToShow);
      left += child.total;
    }
  }
}

function generateLevelsDiffgraph(levels, node, title, level, x, minSamplesToShow) {
  var left = x;

  levels[level] = levels[level] || [];
  if (node.delta_abs >= minSamplesToShow) {
    var change = (node.total_samples_a == 0) ? 1.0 : node.total_delta / node.total_samples_a;
    var color = getDiffColor((node.total_delta > 0), Math.min(Math.abs(change), 1.0));
    levels[level].push({left: left, width: node.delta_abs,
                        self_samples_a: node.self_samples_a,
                        self_samples_b: node.self_samples_b,
                        self_delta: node.self_delta,
                        total_samples_a: node.total_samples_a,
                        total_samples_b: node.total_samples_b,
                        total_delta: node.total_delta,
                        color: color,
                        title: title});

    left += Math.abs(node.self_delta);

    let children = Object.entries(node.children);
    if (sortByNameRadio.checked)
      children.sort((a, b) => a[0].localeCompare(b[0]));
    else
      children.sort((a, b) => b[1].delta_abs - a[1].delta_abs);

    for (let i in children) {
      let title = children[i][0];
      let child = children[i][1];
      generateLevelsDiffgraph(levels, child, title, level+1, left, minSamplesToShow);
      left += child.delta_abs;
    }
  }
}

function generateLevels(levels, node, title, level, x, minSamplesToShow) {
  if (isDiffgraph)
    generateLevelsDiffgraph(levels, node, title, level, x, minSamplesToShow);
  else
    generateLevelsSimple(levels, node, title, level, x, minSamplesToShow);
}

function refreshData() {
  if (isDiffgraph && normalizeDiff)
    b_scale_factor = totalSamplesA / totalSamplesB;

  stacks = transformStacks();

  tree = makeTreeNode();

  depth = parseStacksToTree(stacks, tree);
  smallestPixelsPerSample = canvasWidth / (tree.total || tree.delta_abs);
  minSamplesToShow = minPixelsPerFrame / smallestPixelsPerSample;

  levels = [];
  generateLevels(levels, tree, "all", 0, 0, minSamplesToShow);
  depth = levels.length;
}

refreshData();

var canvasHeight;

function initCanvas() {
  canvasHeight = (depth + 1) * 16;
  canvas.style.width = canvasWidth + 'px';
  canvas.width = canvasWidth * (devicePixelRatio || 1);
  canvas.height = canvasHeight * (devicePixelRatio || 1);
  if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
  c.font = document.body.style.font;
}

initCanvas();
isNormalizedDiv.style.display = isDiffgraph ? 'inherit' : 'none';
if (graphTitle == "")
  titleDiv.style.display = 'none';
else
  graphTitleSpan.innerText = graphTitle;


var highlightPattern = null, currentRootFrame, currentRootLevel, currentFrameUnderCursor, currentLevelUnderCursor, px;

function render(newRootFrame, newLevel) {
  console.time("render");
  // Background
  var gradient = c.createLinearGradient(0, 0, 0, canvasHeight);
  gradient.addColorStop(0.05, "#eeeeee");
  gradient.addColorStop(0.95, "#eeeeb0");
  c.fillStyle = gradient;
  c.fillRect(0, 0, canvasWidth, canvasHeight);

  currentRootFrame = newRootFrame || levels[0][0];
  currentRootLevel = newLevel || 0;
  px = canvasWidth / currentRootFrame.width;

  const marked = [];

  function mark(f) {
    return marked[f.left] >= f.width || (marked[f.left] = f.width);
  }

  function totalMarked() {
    let total = 0;
    let left = 0;
    for (let x in marked) {
      if (+x >= left) {
        total += marked[x];
        left = +x + marked[x];
      }
    }
    return total;
  }

  const x0 = currentRootFrame.left;
  const x1 = x0 + currentRootFrame.width;

  function drawFrame(f, y, alpha) {
    if (f.left < x1 && f.left + f.width > x0) {
      c.fillStyle = highlightPattern && f.title.match(highlightPattern) && mark(f) ? '#ee00ee' : f.color;
      c.fillRect((f.left - x0) * px, y, f.width * px, 15);

      if (f.width * px >= 21) {
        const chars = Math.floor(f.width * px / 7);
        const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
        c.fillStyle = '#000000';
        c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, f.width * px - 6);
      }

      if (alpha) {
        c.fillStyle = 'rgba(255, 255, 255, 0.5)';
        c.fillRect((f.left - x0) * px, y, f.width * px, 15);
      }
    }
  }

  for (let h = 0; h < levels.length; h++) {
    const y = reverseGraph ? h * 16 : canvasHeight - (h + 1) * 16;
    const frames = levels[h];
    for (let i = 0; i < frames.length; i++) {
      if (frames[i].width >= minSamplesToShow)
        drawFrame(frames[i], y, h < currentRootLevel);
    }
  }

  if (highlightPattern != null) {
    matchContainer.style.display = 'inherit';
    matchedLabel.textContent = pct(totalMarked(), currentRootFrame.width) + '%';
  } else
    matchContainer.style.display = 'none';
  console.timeEnd("render");
}

render();

function round2dig(n) {
  return Math.round(n * 100) / 100;
}

function ratioToPct(n) {
  return ((n > 0) ? "+" : "") + (n * 100).toFixed(2) + "%";
}

function findFrame(frames, x) {
  let left = 0;
  let right = frames.length - 1;

  while (left <= right) {
    const mid = (left + right) >>> 1;
    const f = frames[mid];

    if (f.left > x) {
      right = mid - 1;
    } else if (f.left + f.width <= x) {
      left = mid + 1;
    } else {
      return f;
    }
  }

  if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
  if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

  return null;
}

canvas.onmousemove = function() {
  const h = Math.floor((reverseGraph ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
  currentLevelUnderCursor = h;
  if (h >= 0 && h < levels.length) {
    const f = findFrame(levels[h], event.offsetX / px + currentRootFrame.left);
    currentFrameUnderCursor = f;
    if (f && f.width >= minSamplesToShow) {
      hl.style.left = (Math.max(f.left - currentRootFrame.left, 0) * px + canvas.offsetLeft) + 'px';
      hl.style.width = (Math.min(f.width, currentRootFrame.width) * px) + 'px';
      hl.style.top = ((reverseGraph ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
      // hl.firstChild.textContent = f.title;
      hl.style.display = 'block';
      if (isDiffgraph) {
        var rel_change = (f.total_samples_a == 0) ? 1.0 : f.total_delta / f.total_samples_a;
        var total_change = f.total_delta / tree.total_samples_a;
        canvas.title = `${f.title}\n(${samples(f.total_delta, true)}, ${ratioToPct(rel_change)} self, ${ratioToPct(total_change)} total)`;
        // , self_samples_a: ${f.self_samples_a}, self_samples_b: ${f.self_samples_b},  self_delta: ${f.self_delta},  total_samples_a: ${f.total_samples_a},  total_samples_b: ${f.total_samples_b}, total_delta: ${f.total_delta})`;
      } else
        canvas.title = f.title + '\n(' + samples(f.width) + ', ' + pct(f.width, levels[0][0].width) + '%)';
      canvas.style.cursor = 'pointer';
      status.textContent = 'Function: ' + canvas.title;
      status.style['max-width'] = (canvas.offsetWidth - 150) + 'px';
      return;
    }
  }
  canvas.onmouseout();
}

canvas.onclick = function () {
  if (currentFrameUnderCursor && currentFrameUnderCursor != currentRootFrame) {
    render(currentFrameUnderCursor, currentLevelUnderCursor);
    canvas.onmousemove();
  }
}

canvas.onmouseout = function() {
  hl.style.display = 'none';
  status.textContent = '\xa0';
  canvas.title = '';
  canvas.style.cursor = '';
  currentLevelUnderCursor = -1;
  currentFrameUnderCursor = null;
}

function samples(n, add_plus) {
  return (add_plus && n > 0 ? "+" : "") + (n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')) + ' samples';
}

function pct(a, b) {
  return a >= b ? '100' : (100 * a / b).toFixed(2);
}

//// Configuration panel

function highlightApply() {
  const pattern = highlightInput.value;
  highlightPattern = (pattern == "") ? null : _stringToMaybeRegex(pattern);
  render(currentRootFrame, currentRootLevel);
}

function highlightClear() {
  highlightPattern = null;
  render(currentRootFrame, currentRootLevel);
}

function userTransformsSwap(idx1, idx2) {
  const swap = userTransforms[idx1];
  userTransforms[idx1] = userTransforms[idx2];
  userTransforms[idx2] = swap;
}

function addNewTransformParameterized(type, what, replacement) {
  syncTransformsModelWithUI();
  userTransforms.push(_makeTransform(type, true, what, replacement));
  redrawTransformsSection();
}

function addNewTransform() {
  addNewTransformParameterized(newTransformType.value, "", "");
}

function deleteTransform(originator) {
  syncTransformsModelWithUI();
  userTransforms.splice(originator.internalId, 1);
  redrawTransformsSection();
}

function cloneTransform(originator) {
  syncTransformsModelWithUI();
  const idx = originator.internalId;
  userTransforms.splice(idx+1, 0, Object.assign({}, userTransforms[idx]));
  redrawTransformsSection();
}

function moveTransformUp(originator) {
  const idx = originator.internalId;
  if (idx == 0) return;
  syncTransformsModelWithUI();
  userTransformsSwap(idx-1, idx);
  redrawTransformsSection();
}

function moveTransformDown(originator) {
  const idx = originator.internalId;
  if (idx == userTransforms.length-1) return;
  syncTransformsModelWithUI();
  userTransformsSwap(idx, idx+1);
  redrawTransformsSection();
}

function refreshAfterEnabledToggle() {
  syncTransformsModelWithUI();
  redrawTransformsSection();
}

function oneByClass(container, classname) {
  return container.getElementsByClassName(classname)[0];
}

function syncTransformsModelWithUI() {
  for (var i = 0; i < transformsContainer.children.length; i++) {
    const el = transformsContainer.children[i];
    const model = userTransforms[i];
    userTransforms[i] =
      _makeTransform(model.type, oneByClass(el, 'chkEnabled').checked,
                     oneByClass(el, 'what').value,
                     model.type == 'replace' ? oneByClass(el, 'replacement').value : null);
  }
}

function redrawTransformsSection() {
  transformsContainer.innerHTML = "";
  for (var i = 0; i < userTransforms.length; i++) {
    const transform = userTransforms[i];
    var newEl = (transform.type == 'replace') ?
        transformReplaceTemplate.cloneNode(true) :
        transformFilterTemplate.cloneNode(true);
    newEl.style = '';
    newEl.internalId = i;

    const what = transform.what;
    if (typeof(what) == 'string')
      oneByClass(newEl, 'what').value = what;
    else
      oneByClass(newEl, 'what').value = what.toString().match(/^(\/.+\/)g?$/)[1];

    if (transform.type == 'replace')
      oneByClass(newEl, 'replacement').value = transform.replacement;
    else if (transform.type == 'remove')
      oneByClass(newEl, 'label').textContent = "Remove:";
    oneByClass(newEl, 'chkEnabled').checked = transform.enabled;

    oneByClass(newEl, 'chkEnabled').internalId = i;
    oneByClass(newEl, 'btnMoveUp').internalId = i;
    oneByClass(newEl, 'btnMoveDown').internalId = i;
    oneByClass(newEl, 'btnClone').internalId = i;
    oneByClass(newEl, 'btnDelete').internalId = i;
    transformsContainer.appendChild(newEl);
  }
}

redrawTransformsSection();

function scrollToTopOrBottom() {
  window.scrollTo(0, reverseGraph ? 0 : document.body.scrollHeight);
}

scrollToTopOrBottom();

function applyConfiguration() {
  console.time("apply config");
  minPixelsPerFrame = minFrameWidthInPx.value || 0.25;
  normalizeDiff = isNormalized.checked;
  let reverseChanged = (reverseGraph != isReversedInput.checked);
  reverseGraph = isReversedInput.checked;
  syncTransformsModelWithUI();
  refreshData();
  initCanvas();
  render();
  if (reverseChanged)
    scrollToTopOrBottom();
  console.timeEnd("apply config");
}

function toggleSidebarVisibility() {
  sidebarVisible = !sidebarVisible;
  updateSidebarState();
  applyConfiguration();
}


// Context menu implementation was taken from https://github.com/heapoverride/context-js
// and modified to suit our needs. Licensed Under MIT License, author: @UnrealSec
class ContextMenu {
  constructor(container, items) {
    this.container = container;
    this.dom = null;
    this.shown = false;
    this.root = true;
    this.items = items;
    this._onclick = e => {
      if (this.dom && e.target != this.dom &&
          e.target.parentElement != this.dom &&
          !e.target.classList.contains('item') &&
          !e.target.parentElement.classList.contains('item')) {
        this.hide();
      }
    };
    this._oncontextmenu = e => {
      if (e.target != this.dom &&
          e.target.parentElement != this.dom &&
          !e.target.classList.contains('item') &&
          !e.target.parentElement.classList.contains('item') &&
          currentFrameUnderCursor) {
        e.preventDefault();
        this.hide();
        this.frame = currentFrameUnderCursor;
        this.show(e.clientX, e.clientY);
      }
    };
    this._onblur = e => { this.hide(); };
  }
  getMenuDom() {
    const menu = document.createElement('div');
    menu.classList.add('context');
    for (const item of this.items)
      menu.appendChild(this.itemToDomEl(item));
    return menu;
  }
  itemToDomEl(data) {
    const item = document.createElement('div');
    if (data === null) {
      item.classList = 'separator';
      return item;
    }
    if (data.hasOwnProperty('color') && /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(data.color.toString())) {
      item.style.cssText = `color: ${data.color}`;
    }
    item.classList.add('item');

    const label = document.createElement('span');
    label.classList = 'label';
    label.innerText = data.hasOwnProperty('text') ? data['text'].toString() : '';
    item.appendChild(label);

    if (data.hasOwnProperty('disabled') && data['disabled'])
      item.classList.add('disabled');
    else
      item.classList.add('enabled');

    item.addEventListener('click', e => {
      if (item.classList.contains('disabled')) return;
      if (data.hasOwnProperty('onclick') && typeof data['onclick'] === 'function') {
        const event = {handled: false, item: item, label: label, items: this.items, data: data};
        data['onclick'](event, this.frame);
        if (!event.handled)
          this.hide();
      } else {
        this.hide();
      }
    });
    return item;
  }
  hide() {
    if (this.dom && this.shown) {
      this.shown = false;
      this.container.removeChild(this.dom);
    }
  }
  show(x, y) {
    this.dom = this.getMenuDom();
    this.dom.style.visibility = 'hidden';
    this.dom.style.left = `${x}px`;
    this.dom.style.top = `${y}px`;
    this.shown = true;
    this.container.appendChild(this.dom);

    if (this.dom.offsetWidth + x > document.body.clientWidth)
      this.dom.style.left = `${x-this.dom.offsetWidth}px`;
    if (this.dom.offsetHeight + y > document.body.clientHeight)
      this.dom.style.top = `${y-this.dom.offsetHeight}px`;
    this.dom.style.visibility = 'visible';
  }

  install() {
    this.container.addEventListener('contextmenu', this._oncontextmenu, false);
    this.container.addEventListener('keydown', this._oncontextmenu_keydown);
    this.container.addEventListener('click', this._onclick);
    window.addEventListener('blur', this._onblur);
  }
}

function escapeRegex(regexString) {
  return regexString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function menuHighlight(e, frame) {
  let rx = escapeRegex(frame.title);
  highlightInput.value = "/^" + rx + "$/";
  highlightApply();
}

function menuCopyAsText(e, frame) {
  navigator.clipboard.writeText(frame.title);
}

function menuCopyAsRegex(e, frame) {
  let rx = escapeRegex(frame.title);
  navigator.clipboard.writeText(rx);
}

function menuFilterContaining(e, frame) {
  addNewTransformParameterized('filter', ";" + frame.title + ";", "");
  applyConfiguration();
}

function menuRemoveContaining(e, frame) {
  addNewTransformParameterized('remove', ";" + frame.title + ";", "");
  applyConfiguration();
}

function menuHideFramesAbove(e, frame) {
  let rx = escapeRegex(frame.title);
  addNewTransformParameterized('replace', "/(;" + rx + ";).*/", "$1");
  applyConfiguration();
}

function menuHideFramesBelow(e, frame) {
  let rx = escapeRegex(frame.title);
  addNewTransformParameterized('replace', "/.+(" + rx + ";)/", ";$1");
  applyConfiguration();
}

function menuCollapseRecursive(e, frame) {
  let rx = escapeRegex(frame.title);
  addNewTransformParameterized('replace', "/;(" + rx + ";)+/", ";$1");
  applyConfiguration();
}

function menuCollapseRecursiveWithGaps(e, frame) {
  let rx = escapeRegex(frame.title);
  addNewTransformParameterized('replace', "/;(" + rx + ";).*\\1/", ";$1");
  applyConfiguration();
}

const ctxMenuData = [
  {text: 'Highlight', onclick: menuHighlight },
  {text: 'Copy as text', onclick: menuCopyAsText },
  {text: 'Copy as regex', onclick: menuCopyAsRegex },
  null,
  {text: 'Filter containing stacks', onclick: menuFilterContaining },
  {text: 'Remove containing stacks', onclick: menuRemoveContaining },
  {text: 'Hide frames above', onclick: menuHideFramesAbove },
  {text: 'Hide frames below', onclick: menuHideFramesBelow },
  null,
  {text: 'Collapse recursive', onclick: menuCollapseRecursive },
  {text: 'Collapse recursive (with gaps)', onclick: menuCollapseRecursiveWithGaps},
];

const ctxMenu = new ContextMenu(document.getElementById('canvasDiv'), ctxMenuData);
ctxMenu.install();

    </script>
  </body>
</html>
